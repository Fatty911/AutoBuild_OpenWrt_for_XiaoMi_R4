name: test_upload_to_MEGA.yml
on:
  push:
    branches:
      - main
      - master
    paths:
      - .github/workflows/test_upload_to_MEGA.yml
  workflow_dispatch:


env:
  ACTIONS_STEP_DEBUG: true
  SOURCE: coolsnowwolf

permissions:
  contents: write
  packages: write

jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
      

      - name: Checkout
        uses: actions/checkout@main
      - name: Initialization environment
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo -E apt-get -qq update
          sudo apt -y install python3-pip
          pip install mega.py || pip3 install mega.py || exit 1
          
      - name: 生成测试文件
        run: |
          mkdir openwrt
          tar -cf - openwrt/ | pigz > ${{ env.SOURCE }}.tar.gz
          pwd && ls
          
      - name: Upload to MEGA
        env:
          MEGA_USERNAME: ${{ secrets.MEGA_USERNAME }}  # 从 Secrets 中获取用户名
          MEGA_PASSWORD: ${{ secrets.MEGA_PASSWORD }}  # 从 Secrets 中获取密码
        run: |
          python -c "
          from mega import Mega
          import re
          import os
          
          # 登录 MEGA 账户
          mega = Mega()
          m = mega.login('$MEGA_USERNAME', '$MEGA_PASSWORD')
          
          # 1. 定位或创建目标文件夹
          folder_name = '${{ env.SOURCE }}'
          folder = m.find(folder_name)
          if not folder:
              # 如果文件夹不存在，创建新文件夹并获取句柄
              folder_id = m.create_folder(folder_name)
              print(f"创建新文件夹: {folder_name}, folder_id: {folder_id}")
          else:
              # 如果文件夹存在，处理返回值以获取正确的 folder_id
              if not isinstance(folder, list):
                  folder = [folder]  # 如果是单个元组，转换为列表
              node = folder[0][0]  # 获取节点字典
              folder_id = node['h']  # 从节点字典中提取句柄
              print(f"找到现有文件夹: {folder_name}, folder_id: {folder_id}")
          
          # 2. 检查目标文件夹中是否存在同名文件
          target_file = '${{ env.SOURCE }}.tar.gz'
          existing_files = [
              f for f in m.get_files().values()
              if f.get('t') == 0 and f.get('a', {}).get('n') == target_file and f.get('p') == folder_id
          ]
          
          if existing_files:
              # 3. 提取所有带序号的历史文件并计算最大序号
              all_files_in_folder = [
                  f for f in m.get_files().values()
                  if f.get('t') == 0 and f.get('p') == folder_id
              ]
              max_num = 0
              pattern = re.compile(r'^${{ env.SOURCE }}(?:|_(\d+))\\.tar\\.gz$')
              for file_info in all_files_in_folder:
                  name = file_info.get('a', {}).get('n', '')
                  match = pattern.match(name)
                  if match:
                      num_str = match.group(1)
                      current_num = int(num_str) if num_str else 0
                      max_num = max(max_num, current_num)
              # 4. 重命名旧文件为递增序号（新序号 = max_num + 1）
              new_name = f'${{ env.SOURCE }}_{max_num + 1}.tar.gz'
              existing_file_id = existing_files[0]['h']
              m.rename(existing_file_id, new_name)
              print(f"重命名旧文件为: {new_name}")
          
          # 5. 上传新文件
          local_file = './${{ env.SOURCE }}.tar.gz'
          if os.path.exists(local_file):
              print(f"开始上传文件: {local_file} 到 folder_id: {folder_id}")
              m.upload(local_file, folder_id)
              print("上传完成")
          else:
              raise FileNotFoundError(f"本地文件 {local_file} 不存在")
          "
