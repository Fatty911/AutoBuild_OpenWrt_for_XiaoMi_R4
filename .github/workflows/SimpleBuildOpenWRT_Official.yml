name: Simple Build OpenWRT for Xiaomi Mi Router 4 with Custom Packages

on:
  #手动运行
  workflow_dispatch:
    inputs:
      debug_enabled:
        type: boolean
        description: 'Run the build with tmate debugging enabled (https://github.com/marketplace/actions/debugging-with-tmate)'
        required: true
        default: false
  #文件修改时触发
  push:
    branches:
      - main
    # 添加路径过滤，仅当当前工作流文件被修改时触发
    paths:
      - .github/workflows/SimpleBuildOpenWRT_Official.yml  # 需替换为当前工作流文件的实际路径
  repository_dispatch:
    types: Openwrt.org Source Code Update
env:
  TERM: xterm
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 10240
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'true'
      - name: Checkout Self Repo
        uses: actions/checkout@main
        
          
      - name: Clone OpenWRT.org_Official
        run: |
          git clone http://github.com/openwrt/openwrt openwrt

      - name: Install dependencies
        run: |
          sudo apt update
          sudo apt install -y build-essential musl-tools libncurses5-dev libncursesw5-dev gawk git libssl-dev gettext zlib1g-dev swig rsync ruby unzip libpam0g-dev libcurl4-openssl-dev libdeflate-dev
          pip install requests jq beautifulsoup4 || pip3 install requests jq beautifulsoup4

      - name: Update feeds
        run: |
          cd openwrt
          echo 'src-git passwall https://github.com/xiaorouji/openwrt-passwall' >>feeds.conf.default
          echo 'src-git OpenClash https://github.com/vernesong/OpenClash' >>feeds.conf.default
          echo 'src-git small8 https://github.com/kenzok8/small-package' >>feeds.conf.default
          ./scripts/feeds update -a
          ./scripts/feeds install -a
          cp ../config_for_OpenWrt_org .config
          echo "暂时禁用trojan-plus及其依赖，查找 trojan-plus 的 Makefile 位置"
          # 查找 trojan-plus 的 Makefile
          TARGET_PKG="trojan-plus"
          echo "Finding dependents for $TARGET_PKG..."
      
          # 使用关联数组 (Bash 4.0+) 来存储需要禁用的包名
          declare -A packages_to_disable
          packages_to_disable["$TARGET_PKG"]=1
          queue=("$TARGET_PKG")
          checked_packages=() # 避免循环检查
      
          # 查找所有 Makefile 文件
          find package/ feeds/ -name Makefile > makefile_list.txt
      
          while [ ${#queue[@]} -gt 0 ]; do
            current_pkg="${queue[0]}"
            # Dequeue (remove first element)
            if [ ${#queue[@]} -gt 1 ]; then
              queue=("${queue[@]:1}")
            else
              queue=()
            fi
      
            # 检查是否已处理过
            is_checked=0
            for item in "${checked_packages[@]}"; do [[ "$item" == "$current_pkg" ]] && { is_checked=1; break; }; done
            [[ "$is_checked" -eq 1 ]] && continue
            checked_packages+=("$current_pkg")
      
            echo "Checking reverse dependencies for: $current_pkg"
      
            # 在所有 Makefile 中搜索依赖 current_pkg 的包
            # 注意: 这个 grep 模式可能需要根据实际 DEPENDS 语法调整
            # 它查找 DEPENDS 行包含 "+current_pkg" 或 " current_pkg" (注意边界)
            # 并提取定义该依赖的包名 (通常在 define Package/pkg-name)
            grep -ERl --include=Makefile "DEPENDS:?\+=\s*.*\b\+${current_pkg}\b" package/ feeds/ | while read -r makefile_path; do
              # 尝试从 'define Package/...' 行提取包名
              pkg_name_from_def=$(grep -Eo 'define\s+Package/([a-zA-Z0-9_-]+)' "$makefile_path" | sed 's|define Package/||' | head -n 1)
      
              if [ -n "$pkg_name_from_def" ]; then
                dependent_pkg="$pkg_name_from_def"
                if [[ -z "${packages_to_disable[$dependent_pkg]}" ]]; then
                  echo "  Found dependent: $dependent_pkg"
                  packages_to_disable["$dependent_pkg"]=1
                  queue+=("$dependent_pkg")
                fi
              else
                # 如果无法从 define Package 提取，尝试从路径猜测（不太可靠）
                dependent_pkg=$(basename $(dirname "$makefile_path"))
                # 做一些基本检查，避免非包目录
                if [[ -f "$makefile_path" ]] && [[ "$dependent_pkg" != "$current_pkg" ]] && [[ "$dependent_pkg" != "." ]] && [[ "$dependent_pkg" != ".." ]]; then
                   if [[ -z "${packages_to_disable[$dependent_pkg]}" ]]; then
                      echo "  Found dependent (guessed from path): $dependent_pkg"
                      packages_to_disable["$dependent_pkg"]=1
                      queue+=("$dependent_pkg")
                   fi
                fi
              fi
            done
          done
      
          rm makefile_list.txt
      
          echo "--- Packages to disable ---"
          printf "%s\n" "${!packages_to_disable[@]}"
          echo "---------------------------"
      
          echo "Modifying .config to disable packages..."
          for pkg in "${!packages_to_disable[@]}"; do
            # 将包名转换为 CONFIG_PACKAGE_ 格式 (通常是替换 - 为 _)
            config_var="CONFIG_PACKAGE_${pkg//-/_}"
            # 使用 sed 安全地注释掉相关行，并确保添加 # ... is not set
            sed -i -e "/^${config_var}=/s/^/# /" -e "/^# ${config_var} is not set/d" .config
            echo "# ${config_var} is not set" >> .config
            echo "Disabled: $pkg ($config_var)"
          done
      
          # 清理 .config 文件，移除重复的 "is not set" 行
          awk '!seen[$0]++' .config > .config.tmp && mv .config.tmp .config
          
          # 6. 重新生成配置
          make defconfig
          
          echo "验证禁用效果grep 'CONFIG_PACKAGE_trojan-plus' .config " 
          grep 'CONFIG_PACKAGE_trojan-plus' .config
    
          # echo "在defconfig之后查看配置文件"
          # cat .config | grep CONFIG_TARGET_.*=y
          
          
      - name: Download package
        id: download_package
        run: |
          cd openwrt
          make download -j2
          find dl -size -1024c -exec ls -l {} \;
          find dl -size -1024c -exec rm -f {} \;     

      - name: Compile tools
        id: compile_tools
        run: |
          cd openwrt
          make tools/install -j$(nproc) V=s > tools.log 2>&1 || make tools/install -j1 V=s > tools.log 2>&1

      - name: Compile toolchain
        id: compile_toolchain
        run: |
          cd openwrt
          make toolchain/install -j$(nproc) V=s > toolchain.log 2>&1 || make toolchain/install -j1 V=s > toolchain.log 2>&1
          make -j$(nproc) package/feeds/luci/luci-base/compile V=s || make -j$(nproc) package/luci/modules/luci-base/compile V=s || make -j1 package/feeds/luci/luci-base/compile V=s || make -j1 package/luci/modules/luci-base/compile V=s
          
      - name: Compile kernel
        id: compile_kernel
        run: |
          cd openwrt
          make target/linux/compile -j$(nproc) V=s > kernel.log 2>&1 || make target/linux/compile -j1 V=s > kernel.log 2>&1
          
      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.debug_enabled }}
        with:
          limit-access-to-actor: false
          timeout-minutes: 300
          
      - name: Compile packages
        id: compile_packages
        run: |
          cd openwrt
          cp ../compile_with_retry.py .
          # echo "先尝试编译容易失败的lua-neturl"
          # cp ../compile_with_retry.py . && python compile_with_retry.py "make -j1 package/feeds/small8/lua-neturl/compile V=s" "packages.log" 8
          echo "先尝试编译容易失败的trojan-plus"
          python compile_with_retry.py "make -j1 package/feeds/small8/trojan-plus/compile V=s" "packages.log" 6
          echo "开始尝试编译所有packages" 
          # cp ../compile_with_retry.sh . && bash compile_with_retry.sh "make -j1 package/compile V=s" "packages.log" 8 
          #cp ../compile_with_retry.py .
          python compile_with_retry.py "make -j1 package/compile V=s" "packages.log" 8 
          


      
      - name: Build image
        id: build_image
        run: |
          cd openwrt
          LOG_FILE="image.log"
          # cp ../compile_with_retry.sh . && bash compile_with_retry.sh "make -j1 V=s" "image.log" 7 
          # cp ../compile_with_retry.py . 
          python compile_with_retry.py "make -j1 V=s" "image.log" 7 

          
          
      - name: 查看日志结尾300行
        if: always()
        run: |
          cd openwrt
          if [ "${{ steps.compile_tools.outcome }}" = "failure" ]; then             
            echo "Compile tools failed. Showing last 300 lines of tools.log:"             
            tail -300 tools.log           
          elif [ "${{ steps.compile_toolchain.outcome }}" = "failure" ]; then             
            echo "Compile toolchain failed. Showing last 300 lines of toolchain.log:"             
            tail -300 toolchain.log           
          elif [ "${{ steps.compile_kernel.outcome }}" = "failure" ]; then             
            echo "Compile kernel failed. Showing last 300 lines of kernel.log:"             
            tail -300 kernel.log           
          elif [ "${{ steps.compile_packages.outcome }}" = "failure" ]; then             
            echo "编译packages失败，查看日志结尾300 lines of packages.log:"             
            tail -300 packages.log     
          elif [ "${{ steps.build_image.outcome }}" = "failure" ]; then             
            echo "Build image failed. Showing last 300 lines of image.log:"             
            tail -300 image.log           
          else             
            echo "All steps completed successfully. No log to show."           
          fi 
          
      - name: Set environment variables
        id: setEnv
        if: steps.build_image.outcome == 'success'
        run: |
          cd openwrt
          grep '^CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' > DEVICE_NAME
          [ -s DEVICE_NAME ] && echo "DEVICE_NAME=_$(cat DEVICE_NAME)" >> $GITHUB_ENV
          echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV
          echo "TARGET_BOARD=$(grep '^CONFIG_TARGET_BOARD=' .config | sed -r 's/.*="(.*)"/\1/')" >> $GITHUB_ENV
          echo "TARGET_SUBTARGET=$(grep '^CONFIG_TARGET_SUBTARGET=' .config | sed -r 's/.*="(.*)"/\1/')" >> $GITHUB_ENV
          echo "TARGET_PROFILE=$(grep '^CONFIG_TARGET_PROFILE=' .config | sed -r 's/.*="(.*)"/\1/' | sed 's/^DEVICE_//')" >> $GITHUB_ENV
          echo "DEVICE_NAME=$TARGET_PROFILE" >> $GITHUB_ENV
          KERNEL_VERSION=$(ls build_dir/target-*_*/linux-*/ | grep -oP 'linux-\K\d+\.\d+\.\d+')
          echo "kernel_version=$KERNEL_VERSION" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT
          
      - name: Check for .bin file after final compilation
        id: check_bin_final
        run: |
          if [ -f "openwrt/bin/targets/*/*/*.bin" ]; then
            echo "FINAL_BIN_EXISTS=true" >> $GITHUB_ENV
          else
            echo "FINAL_BIN_EXISTS=false" >> $GITHUB_ENV
          fi

      - name: Upload firmware
        if: steps.check_bin_final.conclusion == 'success'
        uses: actions/upload-artifact@master
        with:
          name: openwrt-firmware
          path: openwrt/bin/targets/${{ env.TARGET_BOARD }}/${{ env.TARGET_SUBTARGET }}
      
      - name: Generate release tag
        id: generate_release_tag
        if: env.FINAL_BIN_EXISTS == 'true' 
        run: |
          echo "release_tag=OpenWRT.org_${{ env.DEVICE_NAME }}_Kernel_${{ env.kernel_version }}_$(date +"%Y.%m.%d-%H%M")" >> $GITHUB_OUTPUT
          echo "release_tag_status=success" >> $GITHUB_OUTPUT
          echo "release_tag_status: ${{steps.generate_release_tag.outputs.release_tag_status}}"

      - name: Upload firmware to release
        id: up-release
        uses: softprops/action-gh-release@master
        if: steps.generate_release_tag.outputs.release_tag_status == 'success'
        env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_TRIGGER_PAT }}
        with:
            token: ${{ secrets.ACTIONS_TRIGGER_PAT }}
            files: |
              ${{ env.firmware_path }}/*
              openwrt/.config
            name: ${{ steps.generate_release_tag.outputs.release_tag }}
            tag_name: ${{ steps.generate_release_tag.outputs.release_tag }}
                
      - name: Delete workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.ACTIONS_TRIGGER_PAT }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 2
